[TOC]

# 设计安全的账号系统

本文根据[Salted Password Hashing - Doing it Right](https://crackstation.net/hashing-security.htm)、[用户密码加密机制之加盐散列](https://www.cnblogs.com/zhangming-blog/articles/6018204.html)等文章并加入自己的理解和需求改编而成。

## 背景

最近要对自己开源的[IM](https://github.com/xmcy0011/CoffeeChat)的登录机制进行改造，使用userName+passwor登录。改造前，为了考虑和其他系统对接，是通过userId+token登录的。因为本身token会经过其他业务系统（比如User服务）动态生成，所以明文传递token没啥大问题。但是用户名+密码形式，就需要考虑安全性的问题了，主要有2个方面：**传输安全（TCP）**和**存储安全（MySQL）**。

**传输安全**：如果你使用过wireshark等抓包工具，你应该明白一个道理，从客户端到服务端，中间不知经过了多少个网络设备，只要有心人在中间的某个节点（比如路由器）进行抓包，你所有的东西都相当于是公开的。如果是TCP+自定义结构体，对方只要猜到结构体的内存布局，就可以轻而易举解析出明文内容。如果是TCP+Protobuf，则Protubuf会做一层压缩编码，但如果你用wireshak抓过包，你会发现Protobuf里面存放的是字符串直接能看到内容。解决这个问题，有2种方式；

- 通道加密：我们可以使用SSL，对通道级别进行加密，里面流的都是明文。HTTPS就是这种原理，所以我们如果直接升级TCP到TSL（SSL），一定程度上能缓解这个问题。但是有个原则：**不要在网络上传输明文密码**，所以我们得再找找有没有更好的方案。
- 内容加密：如果通道是TCP，我们对内容进行加密其实也可以。主要有对称加密（如AES、DES）和非对称加密（如RSA）2大类。对称加密性能好，但是密钥放在那里是个问题，据说微信对内容进行加密了，使用了AES128算法。非对称加密因为不太熟悉，所以暂且不谈。内容加密是对整个数据部进行加密，如果对方拿到密钥，也能解析出明文密码，所以还是得找到**单独对密码进行加密**的方法。

**存储安全**：拿用户密码举例，上大学的时候，我们很大可能性会用一个password存储用户的明文密码，然后和用户输入的判等就完成了用户名和密码的校验。但在实际的项目中，特别是很多互联网大公司，都有专业的运维DBA来管数据库。也会实现环境隔离，比如有些公司有MIT（联调）、TEST（测试）、UAT（验收）和PROD（生产）等环境。非生产环境你随意查看修改，而生产环境管理都非常严格，只允许读不允许修改。你设想如果把用户密码明文存储，那所有的研发都能直接看到用户密码，岂不是存在非常多的安全隐患？所以大家肯定都不会直接存储明文，最简单的做一次MD5，存储MD5也要强很多对吧。

所以，总结一下，不管是传输安全还是存储安全，肯定都不能用明文密码。接下来，我们看一下现在主流的基于随机salt（盐值）和hash算法的加密方案。

## 哈希加密基础

### 为什么密码需要进行哈希？

```c++
hash("hello") = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
hash("hbllo") = 58756879c05c68dfac9866712fad6a93f8146f337a69afe7dd238f3364946366
hash("waltz") = c0e81794384491161f1777c232bc6bd9ec38f616560b120fda8e90f383853542
```

上面是3个例子，通过一个算法，生成了完全不一样的定长64位的字符串。哈算算法的特点是：

- 哈希算法是一个单向函数，**无法被反向计算**，有点类似MD5。
- 它可以将**任何大小**的数据转化为**定长**的“指纹”（比如上述都是64位）。
- 即使数据源只改动了一丁点，哈希的结果也会完全不同（参考上面的例子）。

这样的特性使得它非常适合用于保存密码，因为我们需要加密后的密码无法被解密，同时也能保证正确校验每个用户的密码。

### 哈希加密算法使用流程是怎样的？

在基于哈希加密的账户系统中，通常用户注册和认证的流程是这样的：

1. 用户注册一个帐号
2. 密码经过哈希加密储存在数据库中。只要密码被写入磁盘，任何时候都不允许是明文
3. 当用户登录的时候，从数据库取出已经加密的密码，和经过哈希的用户输入进行对比
4. 如果哈希值相同，用户获得登入授权，否则，会被告知输入了无效的登录信息
5. 每当有用户尝试登录，以上两步都会重复

> PS：在第4步中，永远不要告诉用户到底是用户名错了，还是密码错了。只需要给出一个大概的提示，比如“无效的用户名或密码”。这可以防止攻击者在不知道密码的情况下，枚举出有效的用户名。



## 参考

- [设计安全的账号系统的正确姿势](https://blog.coderzh.com/2016/01/03/security-design/)
- [即使被拖库，也可以保证密码不泄露](https://blog.coderzh.com/2016/01/10/a-password-security-design-example/)
- [Salted Password Hashing - Doing it Right](https://crackstation.net/hashing-security.htm)（[翻译：加盐密码哈希：如何正确使用](https://www.cnblogs.com/walkerwang/p/3612110.html)）